import os
import sys

import click

import popper.cli
from popper.cli import pass_context, log
from popper.gha import WorkflowRunner
from popper.parser import Workflow
from popper import log as logging


@click.command(
    'run', short_help='Run a workflow or step.')
@click.argument(
    'step',
    required=False
)
@click.option(
    '-f',
    '--wfile',
    help='File containing the definition of the workflow.',
    required=True
)
@click.option(
    '--debug',
    help=(
        'Generate detailed messages of what popper does (overrides --quiet)'),
    required=False,
    is_flag=True
)
@click.option(
    '--dry-run',
    help='Do not run the workflow, only print what would be executed.',
    required=False,
    is_flag=True
)
@click.option(
    '--log-file',
    help='Path to a log file. No log is created if this is not given.',
    required=False
)
@click.option(
    '--on-failure',
    help='Run the given step if there is a failure.',
    required=False
)
@click.option(
    '--parallel',
    help='Execute steps contained in stage in parallel.',
    required=False,
    is_flag=True
)
@click.option(
    '--quiet',
    help='Do not print output generated by steps.',
    required=False,
    is_flag=True
)
@click.option(
    '--reuse',
    help='Reuse containers between executions (persist container state).',
    required=False,
    is_flag=True,
)
@click.option(
    '--engine',
    help='Specify runtime for executing the workflow [default: docker].',
    type=click.Choice(['docker', 'singularity', 'vagrant']),
    required=False,
    default='docker'
)
@click.option(
    '--skip',
    help=('Skip the given step (can be given multiple times).'),
    required=False,
    default=list(),
    multiple=True
)
@click.option(
    '--skip-clone',
    help='Skip cloning repositories (assume they have been cloned).',
    required=False,
    is_flag=True
)
@click.option(
    '--skip-pull',
    help='Skip pulling container images (assume they exist in local cache).',
    required=False,
    is_flag=True
)
@click.option(
    '--substitution',
    help=('A key-value pair defining a substitution. '
          'Can be given multiple times.'),
    required=False,
    default=list(),
    multiple=True
)
@click.option(
    '--allow-loose',
    help='Do not throw an error if a substitution variable passed as an '
    'argument is unused in the workflow definition.',
    required=False,
    is_flag=True
)
@click.option(
    '--with-dependencies',
    help='When STEP is given, execute all its dependencies as well.',
    required=False,
    is_flag=True
)
@click.option(
    '-w',
    '--workspace',
    help='Path to workspace folder.',
    required=False,
    show_default=False,
    hidden=True,
    default=popper.scm.get_git_root_folder()
)
@click.option(
    '-c', '--conf', help='Runtime configuration options.', required=False
)
@pass_context
def cli(ctx, **kwargs):
    """Runs a Popper workflow. Only execute STEP if given."""
    # set the logging levels.
    level = 'STEP_INFO'
    if kwargs['quiet']:
        level = 'INFO'
    if kwargs['debug']:
        level = 'DEBUG'
    log.setLevel(level)
    if kwargs['log_file']:
        logging.add_log(log, kwargs['log_file'])

    # remove the unnecessary kwargs.
    kwargs.pop('quiet')
    kwargs.pop('debug')
    kwargs.pop('log_file')

    _run_workflow(**kwargs)


def _run_workflow(**kwargs):
    """Runs the workflow for the set parameters.

    Args:
      **kwargs: key-worded,variable-length argument dictionary.

    Returns:
        None

    """
    log.info('Running workflow defined in ' + kwargs['wfile'])

    # Initialize a Workflow. During initialization all the validation
    # takes place automatically.

    wf = Workflow.new_workflow(kwargs['wfile'], kwargs['substitution'],
                               kwargs['allow_loose'])
    wf_runner = WorkflowRunner(wf)

    # remove substitution arguments from kwargs
    kwargs.pop('substitution')
    kwargs.pop('allow_loose')

    # Check for injected steps
    pre_wfile = os.environ.get('POPPER_PRE_WORKFLOW_PATH')
    post_wfile = os.environ.get('POPPER_POST_WORKFLOW_PATH')

    # Saving workflow instance for signal handling
    popper.cli.interrupt_params['parallel'] = kwargs['parallel']

    if kwargs['parallel']:
        if sys.version_info[0] < 3:
            log.fail('--parallel is only supported on Python3')
        log.warning("Using --parallel may result in interleaved output. "
                    "You may use --quiet flag to avoid confusion.")

    if kwargs['with_dependencies'] and (not kwargs['step']):
        log.fail('`--with-dependencies` can only be used when '
                 'STEP argument is given.')

    if kwargs['skip'] and kwargs['step']:
        log.fail('`--skip` can not be used when STEP argument is passed.')

    on_failure = kwargs.pop('on_failure')
    wfile = kwargs.pop('wfile')

    try:
        if pre_wfile:
            pre_wf = Workflow.new_workflow(pre_wfile)
            pre_wf_runner = WorkflowRunner(pre_wf)
            pre_wf_runner.run(**kwargs)

        wf_runner.run(**kwargs)

        if post_wfile:
            post_wf = Workflow.new_workflow(post_wfile)
            pre_wf_runner = WorkflowRunner(post_wf)
            pre_wf_runner.run(**kwargs)

    except SystemExit as e:
        if (e.code != 0) and on_failure:
            kwargs['skip'] = list()
            kwargs['step'] = on_failure
            wf_runner.run(**kwargs)
        else:
            raise

    if kwargs['step']:
        log.info('Step "{}" finished successfully.'.format(kwargs['step']))
    else:
        log.info('Workflow "{}" finished successfully.'.format(wfile))
