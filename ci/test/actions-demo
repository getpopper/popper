#!/bin/bash
set -ex
# shellcheck source=./ci/test/common
source ./common

delete_dir /tmp/gha-demo
git clone https://github.com/cplee/github-actions-demo /tmp/gha-demo
pushd /tmp/gha-demo
PHONY_SECRET=phony popper run --debug
popd

# test with an action defined on the root of the repo
delete_dir /tmp/npm
git clone https://github.com/actions/npm /tmp/npm
pushd /tmp/npm
DOCKER_USERNAME=foo DOCKER_PASSWORD=bar popper run "Integration Test"
popd

# test with a remote action defined on the root of the repo
init_test_repo
cd $test_repo_path
cat <<EOF > main.workflow
workflow "action on root folder" {
  resolves = "test"
}
action "test" {
  uses = "popperized/ansible@master"
  args = "--version"
  secrets = ["ANSIBLE_SSH_KEY_DATA"]
}
EOF

ANSIBLE_SSH_KEY_DATA="$(echo 'dummydata' | base64)" popper run

# test with actions hosted on gitlab
cd $test_repo_path
cat <<EOF > main.workflow
workflow "clone" {
  resolves = "test"
}

action "dependency four" {
  uses = "docker://busybox"
  runs = ["ls", "-ltr"]
}

action "dependency three" {
  uses = "docker://busybox"
  runs = ["ls", "-ltr"]
}

action "dependency two" {
  needs = ["dependency three", "dependency four"]
  uses = "docker://busybox"
  runs = ["ls", "-ltr"]
}

action "dependency one" {
  needs = ["dependency two"]
  uses = "docker://busybox"
  runs = ["ls", "-ltr"]
}

action "test" {
  needs = ["dependency one"]
  uses = "https://gitlab.com/barbaragd/action-test@master"
}
EOF

popper run --dry-run

# test --with-dependencies flag
popper run --dry-run test
popper run --dry-run --with-dependencies test
popper run --dry-run --with-dependencies 'dependency one'


cat <<EOF > main.workflow
workflow "wf" {
  resolves = "d"
}

action "a1" {
  uses = "sh"
  args = "ls"
}

action "a2" {
  uses = "sh"
  args = "ls"
}

action "b" {
  needs = ["a1", "a2"]
  uses = "sh"
  args = "ls"
}

action "c" {
  needs = ["a1", "a2"]
  uses = "sh"
  args = "ls"
}

action "d" {
  needs = ["b", "c"]
  uses = "sh"
  args = "ls"
}
EOF

! popper run --dry-run --with-dependencies
popper run --dry-run --with-dependencies a1
popper run --dry-run --with-dependencies a2
popper run --dry-run --with-dependencies b
popper run --dry-run --with-dependencies c
popper run --dry-run --with-dependencies d

cat <<EOF > main.workflow
workflow "wf" {
  resolves = "d"
}

action "a1" {
  uses = "sh"
  args = "ls"
}

action "a2" {
  uses = "sh"
  args = "ls"
}

action "b" {
  needs = ["a1", "a2"]
  uses = "sh"
  args = "ls"
}

action "c" {
  needs = ["a1", "a2"]
  uses = "sh"
  args = "ls"
}

action "d" {
  needs = ["a2"]
  uses = "sh"
  args = "ls"
}
EOF

popper run a1
popper run a2
popper run b
popper run c
popper run d
popper run --with-dependencies b
popper run --with-dependencies d

# test bindings
init_test_repo
cd $test_repo_path

echo "popper-at-HOME" > "$HOME/popperfile"
echo "popper-at-WORKSPACE" > "./popperfile"

mkdir -p docker-helloworld

cat <<EOF > docker-helloworld/Dockerfile
FROM alpine:3.9
ENTRYPOINT ["echo", "'hello world!'"]
EOF

cat <<EOF > main.workflow
workflow "test bindings" {
  resolves = [
    "did",
    "ws",
    "home"
  ]
}
action "did" {
  uses = "actions/docker/cli@master"
  args = "build -t helloworld docker-helloworld"
}
action "ws" {
  uses = "actions/bin/sh@master"
  runs = ["sh", "-c", "cat \$GITHUB_WORKSPACE/popperfile"]
}
action "home" {
  uses = "actions/bin/sh@master"
  runs = ["sh", "-c", "cat \$HOME/popperfile"]
}
EOF

popper run

rm "$HOME/popperfile" ./popperfile

# test deeply nested action directories
init_test_repo
cd $test_repo_path

cat <<EOF > main.workflow
workflow "test deeply nested action" {
  resolves = ["test"]
}

action "test" {
  uses = "jayjeetatgithub/sample-action/l1/l2/l3/l4/sh@master"
  args = ["ls"]
}
EOF

popper run --debug

# test on-failure flag
init_test_repo
cd $test_repo_path

cat <<EOF > main.workflow
workflow "test-on-failure" {
  resolves = ["test"]
}

action "test" {
  uses = "sh"
  args = ["lss"]
}

action "cleanup" {
  uses = "sh"
  args = ["echo", "Cleaning up..."]
}
EOF

# test action fails, cleanup runs successfully.
popper run --on-failure cleanup

# test action fails, clean action couldnt be found.
! popper run --on-failure clean

cat <<EOF > main.workflow
workflow "test-on-failure" {
  resolves = ["test"]
}

action "test" {
  uses = "sh"
  args = ["lss"]
}

action "cleanup" {
  uses = "sh"
  args = ["echdo", "Cleaning up..."]
}
EOF

# test action fails, cleanup action also fails.
! popper run --on-failure cleanup

cat <<EOF > main.workflow
workflow "test-on-failure" {
  resolves = ["test"]
}

action "test" {
  uses = "sh"
  args = ["lss"]
}

action "cleanup" {
  uses = "sh"
  args = ["echo", "Cleaning up..."]
}
EOF

# test action fails, no --on-failure cleanup action.
! popper run

cat <<EOF > main.workflow
workflow "test-on-failure" {
  resolves = ["test"]
}

action "test" {
  uses = "sh"
  args = ["ls", "-ltr"]
}

action "cleanup" {
  uses = "sh"
  args = ["echo", "Cleaning up..."]
}
EOF

# test action runs sucessfully, cleanup action in not triggered
popper run --on-failure cleanup
